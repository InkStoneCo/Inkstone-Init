// Inkstone Project Scaffold
// Sprint 2.1 實作

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

/**
 * AI Tool type
 */
export type AITool = 'claude' | 'gemini' | 'codex';

/**
 * Scaffold options
 */
export interface ScaffoldOptions {
  tools: AITool[];
  workspaceRoot: string;
  overwrite?: boolean;
}

/**
 * Directory structure to create
 */
const DIRECTORY_STRUCTURE = [
  'requirements/initial/rfp',
  'requirements/initial/rfp/Gherkin',
  'requirements/initial/proposal',
  'user-requirements',
  'rfp',
];

/**
 * Create directory structure for Inkstone project
 */
export async function createDirectoryStructure(workspaceRoot: string): Promise<void> {
  for (const dir of DIRECTORY_STRUCTURE) {
    const dirPath = path.join(workspaceRoot, dir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }
}

/**
 * Check if project is already initialized
 */
export function isProjectInitialized(workspaceRoot: string): boolean {
  const markers = [
    '.claude/settings.json',
    '.gemini/config.yaml',
    'AGENTS.md',
    'codemind.md',
  ];

  return markers.some(marker =>
    fs.existsSync(path.join(workspaceRoot, marker))
  );
}

/**
 * Get Claude settings template
 */
export function getClaudeSettingsTemplate(): object {
  return {
    hooks: {
      notification: [
        {
          matcher: ".*",
          command: "terminal-notifier -title 'Claude Code' -message '$NOTIFICATION_MESSAGE' -sound default || notify-send 'Claude Code' '$NOTIFICATION_MESSAGE' || echo 'Notification: $NOTIFICATION_MESSAGE'"
        }
      ],
      preToolUse: [
        {
          matcher: "Write|Edit",
          command: "echo 'File operation: $TOOL_NAME on $FILE_PATH'"
        }
      ],
      stop: [
        {
          matcher: ".*",
          command: "terminal-notifier -title 'Claude Code' -message 'Task completed' -sound Glass || notify-send 'Claude Code' 'Task completed' || echo 'Task completed'"
        }
      ]
    }
  };
}

/**
 * Get CLAUDE.md template
 */
export function getClaudeMdTemplate(projectName: string): string {
  return `# CLAUDE.md - ${projectName} 開發指南

## 專案概述

此專案使用 Inkstone 進行 AI 輔助開發。

## 開發流程

1. 使用 \`/vibe-coding\` 啟動需求分析工作流程
2. 使用 Code-Mind 筆記系統記錄重要決策
3. 使用 Memory 功能保存和恢復上下文

## 記憶系統

\`\`\`bash
# 保存記憶
claude-flow memory store "key" "value"

# 查詢記憶
claude-flow memory query "key"

# 恢復記憶
claude-flow memory export && cat memory-export-*.json
\`\`\`

## SPARC 開發模式

\`\`\`bash
claude-flow sparc run architect "設計系統架構"
claude-flow sparc run coder "實作功能"
claude-flow sparc run tdd "建立測試"
\`\`\`

## Hive-Mind 協調

\`\`\`bash
claude-flow hive init --topology mesh --agents 3
claude-flow hive status
\`\`\`

---

**版本**: Inkstone Init v1.0
`;
}

/**
 * Get Gemini config template
 */
export function getGeminiConfigTemplate(): string {
  return `# Gemini CLI Configuration
# Generated by Inkstone

model: gemini-2.0-flash
context:
  - codemind.md
  - rfp/requirements.md
  - rfp/design.md

settings:
  auto_save: true
  format: markdown
`;
}

/**
 * Get AGENTS.md template for Codex
 */
export function getAgentsMdTemplate(projectName: string): string {
  return `# AGENTS.md - ${projectName}

## Project Structure

This project uses Inkstone for AI-assisted development.

### Key Files

- \`codemind.md\` - Code-Mind notes (Zettelkasten)
- \`rfp/requirements.md\` - User stories and acceptance criteria
- \`rfp/design.md\` - System design documentation
- \`rfp/tasks.md\` - Task breakdown

### Development Guidelines

1. Read \`rfp/\` directory before making changes
2. Use Code-Mind notes to document decisions
3. Follow SPARC methodology for development

### Memory System

Important context is stored in \`codemind.md\` with \`type: memory\` notes.
`;
}

/**
 * Get AI_GUIDE.md template
 */
export function getAIGuideTemplate(projectName: string, tools: AITool[]): string {
  const toolsList = tools.map(t => `- ${t.charAt(0).toUpperCase() + t.slice(1)}`).join('\n');

  return `# AI_GUIDE.md - ${projectName}

## 專案結構

\`\`\`
${projectName}/
├── requirements/           # 需求文件
│   └── initial/
│       ├── rfp/           # AI 生成的規格文件
│       │   └── Gherkin/   # Gherkin 測試腳本
│       └── proposal/      # 提案文件
├── user-requirements/      # 用戶原始需求
├── rfp/                    # 當前版本規格
├── codemind.md            # Code-Mind 筆記
└── AI_GUIDE.md            # 本文件
\`\`\`

## 配置的 AI 工具

${toolsList}

## 開發工作流程

### 1. 需求分析

使用 Vibe Coding 工作流程：
1. 理解需求
2. User Story Mapping
3. EARS 驗收標準
4. 系統設計
5. 任務分解

### 2. 開發實作

使用 SPARC 模式：
- Architect: 系統架構設計
- Coder: 功能實作
- TDD: 測試驅動開發

### 3. 記憶管理

- Save Memory: 保存重要上下文
- Restore Memory: 恢復記憶
- Search Memory: 搜尋記憶

## 注意事項

- 所有 AI 生成的內容都會記錄在 \`codemind.md\`
- 使用 \`[[cm.xxx]]\` 格式引用筆記
- 定期使用 Memory 功能保存進度

---

Generated by Inkstone Init
`;
}

/**
 * Create codemind.md if not exists
 */
export function getCodemindTemplate(): string {
  return `# Code-Mind Notes

> Zettelkasten-style notes for AI-assisted development
> Generated by Inkstone

---

<!-- Notes will be added below this line -->
`;
}

/**
 * Scaffold the project with selected AI tools
 */
export async function scaffoldProject(options: ScaffoldOptions): Promise<void> {
  const { tools, workspaceRoot, overwrite } = options;

  // Check if already initialized
  if (!overwrite && isProjectInitialized(workspaceRoot)) {
    const answer = await vscode.window.showWarningMessage(
      'Project appears to be already initialized. Do you want to continue?',
      'Yes, overwrite',
      'Cancel'
    );
    if (answer !== 'Yes, overwrite') {
      return;
    }
  }

  // Create directory structure
  await createDirectoryStructure(workspaceRoot);

  // Get project name from workspace
  const projectName = path.basename(workspaceRoot);

  // Create tool-specific files
  for (const tool of tools) {
    switch (tool) {
      case 'claude':
        await createClaudeFiles(workspaceRoot, projectName);
        break;
      case 'gemini':
        await createGeminiFiles(workspaceRoot);
        break;
      case 'codex':
        await createCodexFiles(workspaceRoot, projectName);
        break;
    }
  }

  // Create common files
  await createCommonFiles(workspaceRoot, projectName, tools);
}

/**
 * Create Claude-specific files
 */
async function createClaudeFiles(workspaceRoot: string, projectName: string): Promise<void> {
  const claudeDir = path.join(workspaceRoot, '.claude');
  if (!fs.existsSync(claudeDir)) {
    fs.mkdirSync(claudeDir, { recursive: true });
  }

  // settings.json
  const settingsPath = path.join(claudeDir, 'settings.json');
  if (fs.existsSync(settingsPath)) {
    // Merge with existing settings
    const existing = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
    const template = getClaudeSettingsTemplate() as { hooks: Record<string, unknown[]> };
    const merged = {
      ...existing,
      hooks: {
        ...existing.hooks,
        ...template.hooks,
      },
    };
    fs.writeFileSync(settingsPath, JSON.stringify(merged, null, 2));
  } else {
    fs.writeFileSync(settingsPath, JSON.stringify(getClaudeSettingsTemplate(), null, 2));
  }

  // CLAUDE.md
  const claudeMdPath = path.join(workspaceRoot, 'CLAUDE.md');
  if (!fs.existsSync(claudeMdPath)) {
    fs.writeFileSync(claudeMdPath, getClaudeMdTemplate(projectName));
  }
}

/**
 * Create Gemini-specific files
 */
async function createGeminiFiles(workspaceRoot: string): Promise<void> {
  const geminiDir = path.join(workspaceRoot, '.gemini');
  if (!fs.existsSync(geminiDir)) {
    fs.mkdirSync(geminiDir, { recursive: true });
  }

  const configPath = path.join(geminiDir, 'config.yaml');
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, getGeminiConfigTemplate());
  }
}

/**
 * Create Codex-specific files
 */
async function createCodexFiles(workspaceRoot: string, projectName: string): Promise<void> {
  const agentsPath = path.join(workspaceRoot, 'AGENTS.md');
  if (!fs.existsSync(agentsPath)) {
    fs.writeFileSync(agentsPath, getAgentsMdTemplate(projectName));
  }
}

/**
 * Create common files
 */
async function createCommonFiles(
  workspaceRoot: string,
  projectName: string,
  tools: AITool[]
): Promise<void> {
  // AI_GUIDE.md
  const guidePath = path.join(workspaceRoot, 'AI_GUIDE.md');
  if (!fs.existsSync(guidePath)) {
    fs.writeFileSync(guidePath, getAIGuideTemplate(projectName, tools));
  }

  // codemind.md
  const codemindPath = path.join(workspaceRoot, 'codemind.md');
  if (!fs.existsSync(codemindPath)) {
    fs.writeFileSync(codemindPath, getCodemindTemplate());
  }
}
