// AI Tools Management Module - Sprint 11 實作
// 提供多 AI 工具支援和同步更新功能

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

/**
 * AI 工具類型
 */
export type AIToolType = 'claude' | 'gemini' | 'codex' | 'cursor' | 'windsurf';

/**
 * AI 工具定義
 */
export interface AIToolInfo {
  id: AIToolType;
  name: string;
  description: string;
  icon: string;
  configFile: string;
  configDir?: string;
}

/**
 * 支援的 AI 工具列表
 */
export const AI_TOOLS: AIToolInfo[] = [
  {
    id: 'claude',
    name: 'Claude Code',
    description: 'Anthropic Claude Code CLI',
    icon: 'hubot',
    configFile: 'CLAUDE.md',
    configDir: '.claude',
  },
  {
    id: 'gemini',
    name: 'Gemini CLI',
    description: 'Google Gemini CLI',
    icon: 'sparkle',
    configFile: 'config.yaml',
    configDir: '.gemini',
  },
  {
    id: 'codex',
    name: 'Codex / OpenAI',
    description: 'OpenAI Codex 或相容工具',
    icon: 'robot',
    configFile: 'AGENTS.md',
  },
  {
    id: 'cursor',
    name: 'Cursor',
    description: 'Cursor AI Editor',
    icon: 'edit',
    configFile: '.cursorrules',
  },
  {
    id: 'windsurf',
    name: 'Windsurf',
    description: 'Windsurf AI Editor',
    icon: 'cloud',
    configFile: '.windsurfrules',
  },
];

/**
 * 專案 AI 工具狀態
 */
export interface ProjectAIStatus {
  configuredTools: AIToolType[];
  activeFiles: Map<AIToolType, string>;
  lastSync?: Date;
}

// 狀態變更事件
const _onAIStatusChange = new vscode.EventEmitter<ProjectAIStatus>();
export const onAIStatusChange = _onAIStatusChange.event;

// 快取狀態
let cachedStatus: ProjectAIStatus = {
  configuredTools: [],
  activeFiles: new Map(),
};

/**
 * 掃描專案中配置的 AI 工具
 */
export async function scanAITools(): Promise<ProjectAIStatus> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    return cachedStatus;
  }

  const rootPath = workspaceFolder.uri.fsPath;
  const configuredTools: AIToolType[] = [];
  const activeFiles = new Map<AIToolType, string>();

  for (const tool of AI_TOOLS) {
    let configPath: string;

    if (tool.configDir) {
      configPath = path.join(rootPath, tool.configDir, tool.configFile);
    } else {
      configPath = path.join(rootPath, tool.configFile);
    }

    if (fs.existsSync(configPath)) {
      configuredTools.push(tool.id);
      activeFiles.set(tool.id, configPath);
    }
  }

  cachedStatus = {
    configuredTools,
    activeFiles,
    lastSync: new Date(),
  };

  _onAIStatusChange.fire(cachedStatus);
  return cachedStatus;
}

/**
 * 取得 AI 工具狀態
 */
export function getAIStatus(): ProjectAIStatus {
  return {
    ...cachedStatus,
    activeFiles: new Map(cachedStatus.activeFiles),
  };
}

/**
 * 生成增強版 Gemini config.yaml
 */
export function generateGeminiConfig(projectName: string): string {
  return `# Gemini CLI Configuration
# Generated by Inkstone for ${projectName}
# Documentation: https://ai.google.dev/gemini-api/docs

# 模型設定
model: gemini-2.0-flash-exp
temperature: 0.7
max_output_tokens: 8192

# 上下文文件
context_files:
  # 專案指引
  - AI_GUIDE.md
  - codemind.md

  # 需求文件
  - rfp/proposal/requirements.md
  - rfp/proposal/design.md
  - rfp/proposal/tasks.md

# 系統提示
system_prompt: |
  你是一個專業的軟體開發助手，正在協助開發 ${projectName} 專案。

  開發指引：
  1. 先閱讀 rfp/ 目錄了解需求
  2. 使用 codemind.md 記錄重要決策
  3. 遵循 SPARC 方法論進行開發
  4. 使用繁體中文回覆

  記憶系統：
  - 重要上下文儲存在 codemind.md 中
  - 標記為 type: memory 的筆記是持久記憶

# 安全設定
safety_settings:
  harassment: block_none
  hate_speech: block_none
  sexually_explicit: block_none
  dangerous_content: block_none

# 輸出設定
output:
  format: markdown
  code_execution: true
  auto_save: true

# 工具設定
tools:
  - code_execution
  - google_search

# 快取設定
caching:
  enabled: true
  ttl: 3600
`;
}

/**
 * 生成增強版 AGENTS.md (Codex)
 */
export function generateAgentsMd(projectName: string): string {
  return `# AGENTS.md - ${projectName}

> 此文件為 OpenAI Codex 和相容 AI 工具提供專案上下文

## 專案概述

${projectName} 是一個使用 Inkstone 進行 AI 輔助開發的專案。

## 專案結構

\`\`\`
${projectName}/
├── requirements/           # 多版本需求管理
│   └── {date}-{type}-{name}/
│       ├── rfp/           # 需求規格
│       │   ├── initial-requirements.md
│       │   └── Gherkin/   # 測試腳本
│       └── proposal/      # 提案文件
│           ├── requirements.md  # User Stories + EARS
│           ├── design.md        # 系統設計
│           ├── tasks.md         # 任務分解
│           └── test-cases.md    # 測試案例
├── rfp/                    # 當前版本規格
│   └── proposal/
├── codemind.md            # Code-Mind 筆記（Zettelkasten）
├── AI_GUIDE.md            # AI 開發指引
├── AGENTS.md              # 本文件
└── CLAUDE.md              # Claude 專用指引
\`\`\`

## 關鍵文件

### 需求文件
- \`rfp/proposal/requirements.md\` - User Stories 和 EARS 驗收標準
- \`rfp/proposal/design.md\` - 系統架構和 API 設計
- \`rfp/proposal/tasks.md\` - Sprint 任務分解

### 記憶系統
- \`codemind.md\` - 所有筆記和記憶存放處
- 標記 \`type: memory\` 的筆記為持久記憶
- 使用 \`[[note-id]]\` 進行雙向連結

## 開發方法論

### SPARC 模式
1. **Specification** - 規格定義
2. **Pseudocode** - 偽代碼設計
3. **Architecture** - 架構設計
4. **Refinement** - 精煉實作
5. **Completion** - 完成測試

### Vibe Coding 工作流
1. 理解需求 → \`initial-requirements.md\`
2. User Story Mapping → \`requirements.md\`
3. EARS 驗收標準 → \`requirements.md\`
4. 系統設計 → \`design.md\`
5. 任務分解 → \`tasks.md\`

## 開發指引

### 必須遵守
1. **先讀需求** - 開始前閱讀 \`rfp/\` 目錄
2. **記錄決策** - 重要決策寫入 \`codemind.md\`
3. **增量開發** - 按 Sprint 順序進行
4. **測試驅動** - 每個功能都要有測試

### 最佳實踐
- 使用繁體中文撰寫文件
- 遵循現有程式碼風格
- 保持 commit message 清晰
- 定期同步記憶系統

## 上下文恢復

如果需要恢復上下文，請閱讀以下文件：
1. \`AI_GUIDE.md\` - 專案整體指引
2. \`codemind.md\` - 搜尋 \`type: memory\` 筆記
3. \`rfp/proposal/tasks.md\` - 查看當前進度
`;
}

/**
 * 生成 Cursor 規則文件
 */
export function generateCursorRules(projectName: string): string {
  return `# Cursor Rules for ${projectName}

## Project Context

This project uses Inkstone for AI-assisted development with Code-Mind notes.

## Key Files to Read

- \`AI_GUIDE.md\` - Development guidelines
- \`codemind.md\` - Code-Mind notes and memory
- \`rfp/proposal/requirements.md\` - User stories
- \`rfp/proposal/design.md\` - System design
- \`rfp/proposal/tasks.md\` - Task breakdown

## Development Rules

1. Always read \`rfp/\` directory before making changes
2. Document important decisions in \`codemind.md\`
3. Follow SPARC methodology
4. Use Traditional Chinese for documentation
5. Follow existing code style

## Memory System

- Notes with \`type: memory\` are persistent memory
- Use \`[[note-id]]\` for bidirectional links
- Search memory before starting new features

## Response Guidelines

- Be concise and focused
- Provide code examples when helpful
- Explain architectural decisions
- Suggest tests for new features
`;
}

/**
 * 生成 Windsurf 規則文件
 */
export function generateWindsurfRules(projectName: string): string {
  return `# Windsurf Rules for ${projectName}

## Project Overview

${projectName} uses Inkstone for AI-assisted development.

## Important Files

1. \`AI_GUIDE.md\` - Main development guide
2. \`codemind.md\` - Notes and memory storage
3. \`rfp/proposal/\` - Requirements and design docs

## Development Workflow

### Before Coding
- Read \`rfp/proposal/requirements.md\`
- Check \`rfp/proposal/tasks.md\` for current sprint

### During Development
- Follow SPARC methodology
- Document decisions in \`codemind.md\`
- Write tests for new features

### After Coding
- Update task status
- Save important context to memory

## Code Style

- Use TypeScript with strict mode
- Follow existing patterns
- Keep functions small and focused
- Write meaningful comments

## Language

- Use Traditional Chinese (繁體中文) for:
  - Documentation
  - Comments in code
  - Commit messages
`;
}

/**
 * 同步所有 AI 工具配置
 */
export async function syncAllConfigs(): Promise<void> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    vscode.window.showErrorMessage('請先開啟一個工作區');
    return;
  }

  const rootPath = workspaceFolder.uri.fsPath;
  const projectName = path.basename(rootPath);

  // 掃描現有配置
  await scanAITools();

  const status = getAIStatus();
  if (status.configuredTools.length === 0) {
    vscode.window.showInformationMessage('尚未配置任何 AI 工具');
    return;
  }

  // 同步每個工具的配置
  let syncCount = 0;

  for (const toolId of status.configuredTools) {
    const tool = AI_TOOLS.find(t => t.id === toolId);
    if (!tool) continue;

    try {
      const configPath = status.activeFiles.get(toolId);
      if (!configPath) continue;

      // 根據工具類型更新配置
      let newContent: string | null = null;

      switch (toolId) {
        case 'gemini':
          newContent = generateGeminiConfig(projectName);
          break;
        case 'codex':
          newContent = generateAgentsMd(projectName);
          break;
        case 'cursor':
          newContent = generateCursorRules(projectName);
          break;
        case 'windsurf':
          newContent = generateWindsurfRules(projectName);
          break;
        // Claude 使用 CLAUDE.md，由其他模組管理
      }

      if (newContent) {
        fs.writeFileSync(configPath, newContent, 'utf-8');
        syncCount++;
      }
    } catch (error) {
      console.error(`同步 ${tool.name} 配置失敗:`, error);
    }
  }

  if (syncCount > 0) {
    vscode.window.showInformationMessage(`已同步 ${syncCount} 個 AI 工具配置`);
  }

  // 更新狀態
  cachedStatus.lastSync = new Date();
  _onAIStatusChange.fire(cachedStatus);
}

/**
 * 添加新的 AI 工具
 */
export async function addAIToolHandler(): Promise<void> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    vscode.window.showErrorMessage('請先開啟一個工作區');
    return;
  }

  const rootPath = workspaceFolder.uri.fsPath;
  const projectName = path.basename(rootPath);

  // 掃描現有配置
  await scanAITools();
  const status = getAIStatus();

  // 過濾未配置的工具
  const availableTools = AI_TOOLS.filter(
    t => !status.configuredTools.includes(t.id)
  );

  if (availableTools.length === 0) {
    vscode.window.showInformationMessage('所有 AI 工具都已配置');
    return;
  }

  // 選擇工具
  interface ToolQuickPickItem extends vscode.QuickPickItem {
    tool: AIToolInfo;
  }

  const toolItems: ToolQuickPickItem[] = availableTools.map(t => ({
    label: `$(${t.icon}) ${t.name}`,
    detail: t.description,
    tool: t,
  }));

  const selected = await vscode.window.showQuickPick(toolItems, {
    placeHolder: '選擇要添加的 AI 工具',
    canPickMany: true,
  });

  if (!selected || selected.length === 0) return;

  // 建立配置文件
  for (const item of selected) {
    const tool = item.tool;

    let configPath: string;
    let content: string;

    if (tool.configDir) {
      const dirPath = path.join(rootPath, tool.configDir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
      configPath = path.join(dirPath, tool.configFile);
    } else {
      configPath = path.join(rootPath, tool.configFile);
    }

    switch (tool.id) {
      case 'gemini':
        content = generateGeminiConfig(projectName);
        break;
      case 'codex':
        content = generateAgentsMd(projectName);
        break;
      case 'cursor':
        content = generateCursorRules(projectName);
        break;
      case 'windsurf':
        content = generateWindsurfRules(projectName);
        break;
      default:
        content = `# ${tool.name} Configuration\n\n# Generated by Inkstone\n`;
    }

    fs.writeFileSync(configPath, content, 'utf-8');
  }

  // 刷新狀態
  await scanAITools();

  vscode.window.showInformationMessage(
    `已添加 ${selected.length} 個 AI 工具配置`
  );
}

/**
 * 查看 AI 工具狀態
 */
export async function viewAIStatusHandler(): Promise<void> {
  await scanAITools();
  const status = getAIStatus();

  if (status.configuredTools.length === 0) {
    const action = await vscode.window.showInformationMessage(
      '尚未配置任何 AI 工具',
      '添加工具'
    );
    if (action === '添加工具') {
      await addAIToolHandler();
    }
    return;
  }

  // 顯示狀態選單
  interface StatusQuickPickItem extends vscode.QuickPickItem {
    action: string;
    toolId?: AIToolType;
  }

  const items: StatusQuickPickItem[] = [];

  // 添加已配置的工具
  for (const toolId of status.configuredTools) {
    const tool = AI_TOOLS.find(t => t.id === toolId);
    if (!tool) continue;

    const item: StatusQuickPickItem = {
      label: `$(${tool.icon}) ${tool.name}`,
      description: '已配置',
      action: 'open',
      toolId,
    };
    const filePath = status.activeFiles.get(toolId);
    if (filePath) {
      item.detail = filePath;
    }
    items.push(item);
  }

  items.push({ label: '', kind: vscode.QuickPickItemKind.Separator, action: '' });

  items.push({
    label: '$(add) 添加 AI 工具',
    action: 'add',
  });

  items.push({
    label: '$(sync) 同步所有配置',
    action: 'sync',
  });

  const selected = await vscode.window.showQuickPick(items, {
    placeHolder: `已配置 ${status.configuredTools.length} 個 AI 工具`,
  });

  if (!selected) return;

  switch (selected.action) {
    case 'open':
      if (selected.toolId) {
        const filePath = status.activeFiles.get(selected.toolId);
        if (filePath && fs.existsSync(filePath)) {
          const doc = await vscode.workspace.openTextDocument(filePath);
          await vscode.window.showTextDocument(doc);
        }
      }
      break;
    case 'add':
      await addAIToolHandler();
      break;
    case 'sync':
      await syncAllConfigs();
      break;
  }
}

/**
 * 註冊 AI 工具指令
 */
export function registerAIToolCommands(context: vscode.ExtensionContext): void {
  context.subscriptions.push(
    vscode.commands.registerCommand('inkstone.aiTools.add', addAIToolHandler)
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('inkstone.aiTools.status', viewAIStatusHandler)
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('inkstone.aiTools.sync', syncAllConfigs)
  );

  // 初始掃描
  scanAITools();
}
