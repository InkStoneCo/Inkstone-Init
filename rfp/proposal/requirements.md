# Inkstone-Init 需求規格書

> 版本: 1.0.0
> 日期: 2024-12-24
> 狀態: Draft

---

## Epic 1: VSCode Extension 核心架構

建立統一的 Inkstone VSCode Extension，整合所有功能模組。

### Story 1.1: Extension 基礎架構

**使用者故事：** 作為開發者，我希望有一個統一的 VSCode Extension 入口，以便使用所有 Inkstone 功能。

#### 驗收標準
1. 當用戶安裝 Extension 時，系統應在 VSCode 中註冊 `inkstone` 命名空間的所有指令
2. 當 Extension 啟動時，系統應載入所有子模組（Code-Mind、Init、Vibe Coding）
3. 如果任何子模組載入失敗，系統應顯示錯誤通知並繼續載入其他模組

### Story 1.2: 一鍵安裝體驗

**使用者故事：** 作為 Vibe Coder，我希望從 VSCode Marketplace 搜尋並安裝插件即可使用，以便不需要操作終端機。

#### 驗收標準
1. 當用戶在 VSCode Marketplace 搜尋 "Inkstone" 時，系統應顯示此 Extension
2. 當用戶點擊 Install 時，系統應自動安裝所有依賴，無需額外操作
3. 當安裝完成時，系統應顯示歡迎訊息並引導用戶開始使用

### Story 1.3: Sidebar 面板

**使用者故事：** 作為用戶，我希望在 VSCode 側邊欄看到 Inkstone 面板，以便快速存取所有功能。

#### 驗收標準
1. 當 Extension 啟動時，系統應在 Explorer 區域顯示「Inkstone」面板圖示
2. 當用戶點擊面板時，系統應展開顯示所有功能區塊（Notes、Memory、SPARC、Swarm、Vibe Coding）
3. 當用戶展開任一功能區塊時，系統應顯示該功能的所有可用按鈕

---

## Epic 2: Code-Mind 筆記系統

整合 Zettelkasten 風格的程式碼內筆記功能。

### Story 2.1: 右鍵插入筆記

**使用者故事：** 作為 Vibe Coder，我希望選取文字後右鍵即可插入筆記，以便不需要記憶特殊語法。

#### 驗收標準
1. 當用戶在編輯器中選取文字並右鍵時，系統應在選單中顯示「Inkstone: Add Note」選項
2. 當用戶點擊「Add Note」時，系統應彈出輸入框讓用戶輸入筆記標題
3. 當用戶確認輸入時，系統應自動生成筆記 ID 並在選取位置插入 `[[cm.xxxxxx|標題]]`
4. 當筆記插入成功時，系統應自動更新 `codemind.md` 檔案

### Story 2.2: 筆記自動補全

**使用者故事：** 作為開發者，我希望輸入 `[[` 時自動顯示筆記列表，以便快速引用現有筆記。

#### 驗收標準
1. 當用戶輸入 `[[` 時，系統應顯示所有現有筆記的自動補全列表
2. 當用戶繼續輸入時，系統應即時過濾符合的筆記
3. 當用戶選擇筆記時，系統應自動完成 `[[cm.xxxxxx|標題]]` 格式

### Story 2.3: 筆記樹狀視圖

**使用者故事：** 作為用戶，我希望在側邊欄看到所有筆記的樹狀結構，以便瀏覽和管理知識庫。

#### 驗收標準
1. 當用戶展開 Notes 區塊時，系統應顯示按檔案分組的筆記樹狀結構
2. 當用戶點擊筆記時，系統應跳轉到該筆記在程式碼中的位置
3. 當 `codemind.md` 更新時，系統應自動刷新樹狀視圖

### Story 2.4: 雙向連結導航

**使用者故事：** 作為開發者，我希望點擊筆記引用時跳轉到定義處，以便快速追蹤知識脈絡。

#### 驗收標準
1. 當用戶 Ctrl/Cmd+Click 筆記引用 `[[cm.xxxxxx]]` 時，系統應跳轉到該筆記的定義位置
2. 當用戶 hover 筆記引用時，系統應顯示筆記內容的預覽
3. 當用戶右鍵筆記引用時，系統應顯示「Find All References」選項

### Story 2.5: Daemon 自動啟動

**使用者故事：** 作為用戶，我希望 Code-Mind Daemon 在需要時自動啟動，以便不需要手動執行終端指令。

#### 驗收標準
1. 當用戶執行任何筆記操作時，系統應檢查 Daemon 是否運行
2. 如果 Daemon 未運行，系統應自動在背景啟動 Daemon
3. 當 Daemon 啟動成功時，系統應在狀態列顯示運行狀態圖示

---

## Epic 3: 專案初始化

提供一鍵初始化專案結構的功能。

### Story 3.1: Initialize Project 指令

**使用者故事：** 作為開發者，我希望執行「Inkstone: Initialize Project」指令，以便自動建立標準目錄結構。

#### 驗收標準
1. 當用戶執行 `Inkstone: Initialize Project` 指令時，系統應顯示初始化選項對話框
2. 當用戶確認初始化時，系統應建立所有必要的目錄和檔案
3. 如果專案已初始化，系統應詢問是否覆蓋現有設定

### Story 3.2: 目錄結構生成

**使用者故事：** 作為用戶，我希望初始化後自動建立 `requirements/initial/rfp/` 和 `requirements/initial/proposal/` 目錄，以便有組織地管理需求文件。

#### 驗收標準
1. 當初始化完成時，系統應建立以下目錄結構：
   - `requirements/initial/rfp/`
   - `requirements/initial/rfp/Gherkin/`
   - `requirements/initial/proposal/`
2. 當目錄建立時，系統應在每個目錄放置 README.md 說明用途
3. 如果目錄已存在，系統應保留現有內容

### Story 3.3: AI 工具設定檔

**使用者故事：** 作為開發者，我希望初始化時自動建立 `.claude/`、`.gemini/` 等設定目錄，以便支援多種 AI 工具。

#### 驗收標準
1. 當用戶選擇 Claude Code 時，系統應建立 `.claude/settings.json` 和 `CLAUDE.md`
2. 當用戶選擇 Gemini CLI 時，系統應建立 `.gemini/config.yaml`
3. 當用戶選擇 Codex 時，系統應建立 `AGENTS.md`
4. 當用戶選擇多個工具時，系統應建立所有對應的設定檔

### Story 3.4: Hooks 自動配置

**使用者故事：** 作為用戶，我希望初始化時自動設定 Claude Code hooks，以便獲得通知和 Daemon 自動啟動功能。

#### 驗收標準
1. 當初始化完成時，系統應在 `.claude/settings.json` 中配置 Notification hook
2. 當初始化完成時，系統應在 `.claude/settings.json` 中配置 PreToolUse hook 以自動啟動 Daemon
3. 當用戶已有 hooks 設定時，系統應合併而非覆蓋

---

## Epic 4: Vibe Coding 工作流程

提供從自然語言需求到可執行任務的引導式流程。

### Story 4.1: Start Vibe Coding 指令

**使用者故事：** 作為 Vibe Coder，我希望執行「Inkstone: Start Vibe Coding」或 `/vibe-coding` 開始工作流程，以便將想法轉換為實作計畫。

#### 驗收標準
1. 當用戶執行 `Inkstone: Start Vibe Coding` 時，系統應開啟 Vibe Coding Webview 面板
2. 當用戶在 Claude Code 中輸入 `/vibe-coding` 時，系統應啟動相同的工作流程
3. 當工作流程啟動時，系統應檢測並顯示當前進度階段

### Story 4.2: 階段式引導 UI

**使用者故事：** 作為用戶，我希望有視覺化的引導界面顯示當前階段和進度，以便清楚知道流程進行到哪裡。

#### 驗收標準
1. 當 Webview 開啟時，系統應顯示 5 個階段的進度指示器
2. 當用戶完成一個階段時，系統應自動標記為完成並高亮下一階段
3. 當用戶點擊已完成的階段時，系統應允許返回修改

### Story 4.3: Epics/Stories/EARS 三層結構

**使用者故事：** 作為開發者，我希望需求文件使用 Epic → Story → EARS 三層結構，以便更好地組織大型專案需求。

#### 驗收標準
1. 當生成 requirements.md 時，系統應使用 Epic 作為一級標題
2. 當生成 requirements.md 時，系統應使用 Story 作為二級標題，包含使用者故事描述
3. 當生成 requirements.md 時，系統應在每個 Story 下方列出 EARS 格式的驗收標準

### Story 4.4: Sprint 增量開發規劃

**使用者故事：** 作為專案經理，我希望任務按 Sprint 劃分且每個 Sprint 包含前後端，以便每個階段都可進行 E2E 測試。

#### 驗收標準
1. 當生成 tasks.md 時，系統應將任務按 Sprint 分組
2. 當規劃 Sprint 時，系統應確保每個 Sprint 包含可獨立運行的前後端功能
3. 當 Sprint 包含前端時，系統應明確標註 UI/UX 相關任務

### Story 4.5: Gherkin 測試腳本生成

**使用者故事：** 作為 QA，我希望自動生成 Gherkin 格式的測試腳本，以便進行自動化測試。

#### 驗收標準
1. 當完成 EARS 驗收標準後，系統應自動生成對應的 Gherkin 測試腳本
2. 當生成測試腳本時，系統應將檔案放置在 `requirements/initial/rfp/Gherkin/` 目錄
3. 當測試腳本生成時，系統應使用 Feature/Scenario/Given/When/Then 標準格式

### Story 4.6: Test Cases 交付

**使用者故事：** 作為用戶，我希望每個 Sprint 結束時獲得完整的測試案例（含連結、帳密、測試步驟），以便驗收功能。

#### 驗收標準
1. 當 Sprint 完成時，系統應生成 Test Cases 文件
2. 當生成 Test Cases 時，系統應包含測試環境連結、測試帳號密碼
3. 當生成 Test Cases 時，系統應包含詳細的測試步驟和預期結果

---

## Epic 5: 記憶管理

提供按鈕化的記憶儲存和恢復功能。

### Story 5.1: 儲存記憶按鈕

**使用者故事：** 作為用戶，我希望點擊「Save Memory」按鈕並輸入內容，以便將重要資訊儲存到 `codemind.md`。

#### 驗收標準
1. 當用戶點擊「Save Memory」按鈕時，系統應顯示輸入對話框
2. 當用戶輸入標題和內容時，系統應建立新筆記並標記為「memory」類型
3. 當儲存成功時，系統應顯示成功通知

### Story 5.2: 恢復記憶按鈕

**使用者故事：** 作為用戶，我希望點擊「Restore Memory」按鈕，以便讓 AI 讀取之前儲存的記憶。

#### 驗收標準
1. 當用戶點擊「Restore Memory」按鈕時，系統應讀取所有 memory 類型的筆記
2. 當讀取完成時，系統應將內容格式化並複製到剪貼簿
3. 當用戶使用 Claude Code 時，系統應自動將記憶內容傳遞給 AI

### Story 5.3: 搜尋記憶

**使用者故事：** 作為用戶，我希望搜尋記憶內容，以便快速找到需要的資訊。

#### 驗收標準
1. 當用戶點擊「Search Memory」按鈕時，系統應顯示搜尋輸入框
2. 當用戶輸入關鍵字時，系統應即時顯示符合的筆記列表
3. 當用戶點擊搜尋結果時，系統應跳轉到該筆記位置

---

## Epic 6: SPARC 開發模式

提供一鍵執行各種 SPARC 開發模式的功能。

### Story 6.1: SPARC 模式面板

**使用者故事：** 作為開發者，我希望在側邊欄看到所有 SPARC 模式按鈕，以便快速選擇開發模式。

#### 驗收標準
1. 當用戶展開 SPARC 區塊時，系統應顯示所有可用的開發模式按鈕
2. 當用戶 hover 按鈕時，系統應顯示該模式的簡短說明
3. 當某模式正在執行時，系統應在按鈕上顯示運行狀態

### Story 6.2: Architect 模式

**使用者故事：** 作為開發者，我希望點擊按鈕執行架構設計模式，以便不需要記憶終端指令。

#### 驗收標準
1. 當用戶點擊「Architect」按鈕時，系統應顯示任務描述輸入框
2. 當用戶確認輸入時，系統應在背景執行 `claude-flow sparc run architect` 指令
3. 當執行完成時，系統應通知用戶並顯示結果摘要

### Story 6.3: Coder 模式

**使用者故事：** 作為開發者，我希望點擊按鈕執行編碼模式，以便快速開始實作。

#### 驗收標準
1. 當用戶點擊「Coder」按鈕時，系統應顯示任務描述輸入框
2. 當用戶確認輸入時，系統應在背景執行 `claude-flow sparc run coder` 指令
3. 當執行完成時，系統應通知用戶並顯示結果摘要

### Story 6.4: TDD 模式

**使用者故事：** 作為開發者，我希望點擊按鈕執行測試驅動開發模式，以便建立測試套件。

#### 驗收標準
1. 當用戶點擊「TDD」按鈕時，系統應顯示任務描述輸入框
2. 當用戶確認輸入時，系統應在背景執行 `claude-flow sparc run tdd` 指令
3. 當執行完成時，系統應通知用戶並顯示測試結果

---

## Epic 7: Swarm 協調

提供 Hive-Mind 蜂群協調功能的按鈕化操作。

### Story 7.1: Init Swarm 按鈕

**使用者故事：** 作為開發者，我希望點擊按鈕初始化 Swarm，以便快速啟動多 Agent 協作。

#### 驗收標準
1. 當用戶點擊「Init Swarm」按鈕時，系統應顯示拓撲選擇對話框（mesh/hierarchical/ring/star）
2. 當用戶選擇拓撲時，系統應顯示 Agent 數量設定
3. 當用戶確認時，系統應執行 `claude-flow hive init` 指令

### Story 7.2: Swarm 狀態監控

**使用者故事：** 作為用戶，我希望查看當前 Swarm 的運行狀態，以便了解任務進度。

#### 驗收標準
1. 當 Swarm 正在運行時，系統應在側邊欄顯示狀態摘要
2. 當用戶點擊狀態區塊時，系統應開啟詳細狀態 Webview
3. 當任務完成或失敗時，系統應即時更新狀態並通知用戶

---

## Epic 8: 新需求管理

提供有組織的新需求追蹤機制。

### Story 8.1: 新需求分類判斷

**使用者故事：** 作為專案經理，我希望系統能判斷新需求是「新功能」還是「修正」，以便正確歸檔。

#### 驗收標準
1. 當用戶新增需求時，系統應詢問「這是新功能還是現有功能的修正？」
2. 當用戶選擇「新功能」時，系統應建立新的需求資料夾
3. 當用戶選擇「修正」時，系統應在原有需求資料夾中新增修正記錄

### Story 8.2: 需求版本資料夾

**使用者故事：** 作為開發者，我希望每個新需求有獨立的資料夾（如 `requirements/feature-xxx/`），以便追蹤需求歷史。

#### 驗收標準
1. 當建立新功能需求時，系統應建立 `requirements/{feature-name}/` 資料夾
2. 當建立資料夾時，系統應包含 `rfp/` 和 `proposal/` 子目錄
3. 當列出需求時，系統應按時間順序顯示所有需求版本

---

## Epic 9: 多 AI 工具支援

支援 Claude Code 以外的 AI 開發工具。

### Story 9.1: Gemini CLI 支援

**使用者故事：** 作為 Gemini 用戶，我希望使用相同的專案結構和工作流程，以便無縫切換 AI 工具。

#### 驗收標準
1. 當用戶選擇 Gemini CLI 時，系統應建立 `.gemini/config.yaml` 設定檔
2. 當用戶使用 Gemini CLI 時，系統應能讀取相同的 `codemind.md` 筆記
3. 當用戶切換 AI 工具時，系統應保留所有專案設定和記憶

### Story 9.2: Codex 支援

**使用者故事：** 作為 Codex 用戶，我希望有對應的設定檔（如 `AGENTS.md`），以便 Codex 能理解專案脈絡。

#### 驗收標準
1. 當用戶選擇 Codex 時，系統應建立 `AGENTS.md` 設定檔
2. 當建立 `AGENTS.md` 時，系統應包含專案結構說明和開發指引
3. 當用戶更新專案設定時，系統應同步更新 `AGENTS.md`

### Story 9.3: 通用 AI 指引

**使用者故事：** 作為開發者，我希望有通用的 AI 指引文件，以便任何 AI 工具都能理解專案規範。

#### 驗收標準
1. 當初始化專案時，系統應建立 `AI_GUIDE.md` 通用指引文件
2. 當建立指引時，系統應包含專案結構、開發流程、記憶系統使用說明
3. 當專案設定變更時，系統應提示用戶更新 AI 指引
